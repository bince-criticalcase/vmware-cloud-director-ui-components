<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>vmware-cloud-director-ui-components documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">vmware-cloud-director-ui-components documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content class">
                   <div class="content-data">











<ol class="breadcrumb">
  <li>Classes</li>
  <li>BaseWidgetObject</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/components/src/utils/test/widget-object/widget-object.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>A wrapper around a component in UI code. Each subclass typically lives in the same folder as the
component itself.</p>
<p>It provides two main functions:</p>
<ul>
<li>Access to key HTML elements within it so that tests can assert something about their content</li>
<li>Abstracting interactions. For example, a login method that takes a username and password and
enters it into both fields and then clicks the submit button.</li>
</ul>
<p>These widgets can be used in multiple environments by implementing two pieces:</p>
<ul>
<li>A subclass of WidgetObjectElement<T> where T is the environment&#39;s HTMLElement wrapper, such as DebugElement,
 Cypress.Chainable or WebElement.</li>
<li>A Widget finder that knows how to instantiate WidgetObjects passing it the correct type of <code>WidgetObjectElement&lt;T&gt;</code>
 which you have created</li>
</ul>

            </p>



            <p class="comment">
                <h3>Example</h3>
            </p>
            <div class="io-description">
                        <div>
                            <pre class="line-numbers"><code class="language-html">class LoginWidgetObject&lt;T&gt; extends BaseWidgetObject&lt;T&gt; {
      // Private accessors return WidgetObjectElement using the factory
      private _getUserNameInput = this.internalFactory.css('.username');

      // Public accessors return T and can be composed from their private counterparts
      // Differentiate them by the underscore to make it clear one is returning the internal format
      public getUsernameInput = this.factory.unwrap(this._getUsernameInput);

      // Don't need to expose this publicly, user underscore so it's clear it returns the WidgetObjectElement
      private _getOkButton = this.internalFactory.text('button', OK);

      // Don't need an internal version, use the factory methods to create public methods
      public errorMessage = this.factory.dataUi('error-message');

       // Sometimes there's no factory for more complex finding logic, write a custom query.
       // Be sure to call unwrap on the result if exposing it publicly
      getOkButtonContainer(): T {
          return this.el.getByText('button', 'Ok').parent('.button-container').unwrap();
      }
      ...

      login(user, password) {
          this._getUsernameInput().type(user);
          this._getPasswordInput().type(password);
          this._getOkButton().click();
      }
}</code></pre>
                        </div>
            </div>

            <section>
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>
                <tr>
                    <td class="col-md-4">
                        <h6><b>Properties</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                    <span class="modifier">Protected</span>
                                <a href="#factory">factory</a>
                            </li>
                            <li>
                                    <span class="modifier">Protected</span>
                                <a href="#internalFactory">internalFactory</a>
                            </li>
                        </ul>
                    </td>
                </tr>

                <tr>
                    <td class="col-md-4">
                        <h6><b>Methods</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                    <span class="modifier">Public</span>
                                <a href="#self">self</a>
                            </li>
                        </ul>
                    </td>
                </tr>





        </tbody>
    </table>
</section>

            <section>
    <h3 id="constructor">Constructor</h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
<code>constructor(el: <a href="../interfaces/WidgetObjectElement.html">WidgetObjectElement<T></a>)</code>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="223" class="link-to-prism">projects/components/src/utils/test/widget-object/widget-object.ts:223</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                            <div>
                                    <b>Parameters :</b>
                                    <table class="params">
                                        <thead>
                                            <tr>
                                                <td>Name</td>
                                                    <td>Type</td>
                                                <td>Optional</td>
                                            </tr>
                                        </thead>
                                        <tbody>
                                                <tr>
                                                        <td>el</td>
                                                  
                                                        <td>
                                                                        <code><a href="../interfaces/WidgetObjectElement.html" target="_self" >WidgetObjectElement&lt;T&gt;</a></code>
                                                        </td>
                                                  
                                                    <td>
                                                            No
                                                    </td>
                                                    
                                                </tr>
                                        </tbody>
                                    </table>
                            </div>
                    </td>
                </tr>
            </tbody>
        </table>
</section>

            <section>
    
        <h3 id="inputs">
            Properties
        </h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="factory"></a>
                        <span class="name">
                            <b>
                                <span class="modifier">Protected</span>
                            factory</b>
                            <a href="#factory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/object" target="_blank" >object</a></code>

                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>{
        /**
         * Utility to create versions of factories that return the unwrapped T
         */
        unwrap: (fun: ElementLocator&lt;WidgetObjectElement&lt;T&gt;&gt;) &#x3D;&gt; {
            return (options?: FindElementOptions) &#x3D;&gt; fun(options).unwrap();
        },

        css: (cssSelector: string) &#x3D;&gt; this.factory.unwrap(this.internalFactory.css(cssSelector)),

        /** Utility to find by data-ui attribute which is the suggested way to tag elements in the DOM for testing  */
        dataUi: (name: string) &#x3D;&gt; this.factory.unwrap(this.internalFactory.dataUi(name)),
    }</code>
                        </td>
                    </tr>
                        <tr>
                            <td class="col-md-4">
                                    <div class="io-line">Defined in <a href="" data-line="211" class="link-to-prism">projects/components/src/utils/test/widget-object/widget-object.ts:211</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>Helpers for creating methods to find HTML elements within the widget object. They can find two types of elements:</p>
<ul>
<li><p>WidgetObjectElements<T> which wrap the T which is unknown to this base class into a common interface that
 can be be used within to WidgetObject subclasses to provide methods that can abstract interactions with
 the widget. For example, a <code>loginWidget.login(usr, pwd)</code> call which types into the user and password fields
 and then hits the submit button; These elements don&#39;t provide means to assert anything or even to read
 information from the widget objects elements such as their text, CSS class names, etc.</p>
</li>
<li><p>The generic specified by <T> which depends on the implementation such as a DebugElement in Angular, a
 Chainable in Cypress, or a WebElement in Selenium.</p>
</li>
</ul>
<p>Note that unlike Google Material&#39;s Harnesses, we do not impose a <code>TestElement</code> interface to be used from
different implementations where all the methods return promises. The main reason is that it allows
calls from different implementations to feel more natural, according to their testing environment. For example:</p>
<ul>
<li><p>Avoids adding <code>await</code>s all over unit tests where they aren&#39;t necessarily needed. When trying this approach,
 it was tricky to try to convert Cypress values into Promises in a reliable way. It initially looked promising
 (pun intended) but turned out not to work with nested promises.</p>
</li>
<li><p>Allows the calls to WidgetObject methods to be more like their native objects instead of forcing them
 to comply with a TestElement interface we have defined. That is, Cypress has a natural way to read text at
 polling intervals automatically so you can still benefit from that when writing a Cypress Tests while
 you would need a different mechanism in your Angular unit tests where you have a DebugElement.</p>
<p> This also prevents widget object methods from querying information about the elements forcing any assertions
 to be run from the outside, which we believe is the correct way to structure codes since assertions are
 framework specific.</p>
<p> Each factory method returns an ElementLocator&lt;WidgetObjectElement<T>&gt; which should never be public
 but also has a corresponding method prefixed with _ to indicate the it returns <code>T</code> which is what should be
 consumed by users of the class.</p>
</li>
</ul>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="internalFactory"></a>
                        <span class="name">
                            <b>
                                <span class="modifier">Protected</span>
                            internalFactory</b>
                            <a href="#internalFactory"><span class="icon ion-ios-link"></span></a>
                        </span>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/object" target="_blank" >object</a></code>

                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <i>Default value : </i><code>{
        css: (cssSelector: string) &#x3D;&gt; (options?: FindElementOptions) &#x3D;&gt; this.el.get({ cssSelector, ...options }),
        dataUi: (name: string) &#x3D;&gt; this.internalFactory.css(&#x60;[data-ui&#x3D;&quot;${name}&quot;]&#x60;),
    }</code>
                        </td>
                    </tr>
                        <tr>
                            <td class="col-md-4">
                                    <div class="io-line">Defined in <a href="" data-line="173" class="link-to-prism">projects/components/src/utils/test/widget-object/widget-object.ts:173</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                        <div class="io-description"><p>This is like <a href="#factory">#factory</a> but it returns WidgetObjectElements, which can be used internally</p>
</div>
                    </td>
                </tr>

            </tbody>
        </table>
</section>

            <section>
    
    <h3 id="methods">
        Methods
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="self"></a>
                    <span class="name">
                        <b>
                            <span class="modifier">Public</span>
                            self
                        </b>
                        <a href="#self"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
                    <span class="modifier-icon icon ion-ios-reset"></span>
                    <code>self()</code>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">
                    <div class="io-line">Defined in <a href="" data-line="232"
                            class="link-to-prism">projects/components/src/utils/test/widget-object/widget-object.ts:232</a></div>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>Gives the element that underlies the current widget object. Use sparingly. A common use case is
when you want to test visibility of a widget, which must be done by assertions, which do not belong in a widget
object.</p>
</div>

                    <div class="io-description">
                        <b>Returns : </b>    <code>T</code>

                    </div>
                </td>
            </tr>
        </tbody>
    </table>
</section>





    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">type ElementLocator&lt;T&gt; &#x3D; (options?: FindElementOptions) &#x3D;&gt; T;

/**
 * Like unknown but can be an object but also needs to be cast before it can be used (since an empty object doesn&#x27;t
 * allow properties)
 *
 * These options will be passed down to the implementation when querying or running actions. For example, when
 * specifying a timeout for a cypress command. An implementation specific type should be used in their implementation of
 * the WidgetObjectElement
 */
type UnknownOptions &#x3D; {};

export type FindElementOptions &#x3D; {
    /** CSS selector used to query. Ignored if {@link #dataUiSelector} is passed */
    cssSelector?: string;

    /** Data UI attribute selector used to query */
    dataUiSelector?: string;

    /** To get the nth element of a result set. */
    index?: number;

    /** To search for the element containing the given text. Ignored if {@link #index} is passed */
    text?: string;

    /** An implementation specific parent can be used to start the search */
    ancestor?: unknown;

    /** Implementation specific options. For example, timeouts in cypress */
    options?: UnknownOptions;
};

/**
 * Something that can find other WidgetObjectElements or WidgetObjects within itself
 */
interface Locator&lt;T&gt; {
    /**
     * Finds all descendants by CSS selector
     * @param selector - Can be a CSS query string or a FindElementOptions for more refined querying
     */
    get(selector: string | FindElementOptions): WidgetObjectElement&lt;T&gt;;

    /**
     * Finds the closest parent that matches the given cssSelector. Ignores the index attribute
     */
    parents(selector: string | FindElementOptions): WidgetObjectElement&lt;T&gt;;

    /**
     * Returns an instance of the given widget within this widget object.
     */
    findWidget&lt;W extends BaseWidgetObject&lt;T&gt;&gt;(widget: FindableWidget&lt;T, W&gt;, findOptions?: FindElementOptions): W;
}

/**
 * Actions that can be taken on elements from within widget objects. This
 * is a subset of the functionality from Cypress
 */
export interface ElementActions {
    /**
     * Clicks an element, it must typically be visible
     * @param options Options to be passed down to implementations
     */
    click(options?: UnknownOptions): void;

    /**
     * Types into a text field
     * @param value What to type into the field
     * @param options Options to be passed down to implementations
     */
    type(value: string, options?: UnknownOptions): void;

    /**
     * For checkboxes, makes sure a box is checked
     * @param options Options to be passed down to implementations
     */
    check(options?: UnknownOptions): void;

    /**
     * For checkboxes, makes sure a box is unchecked
     * @param options Options to be passed down to implementations
     */
    uncheck(options?: UnknownOptions): void;

    /**
     * For select elements
     * @param value The text of the dropdown to select
     * @param options Options to be passed down to implementations
     */
    select(value: string, options: UnknownOptions): void;

    /**
     * For inputs or text areas, clears the current value.
     * @param options Options to be passed down to implementations
     */
    clear(options?: UnknownOptions): void;
}

/**
 * Wraps an HTMLElement for internal use from a WidgetObject.
 *
 * It can query for other &#x60;WidgetObjectElement&#x60;s and it can interact with the element itself.
 *
 * This does not provide an interface to read information from the elements because we should not be running assertions
 * from the widget object.
 *
 * &#x60;T&#x60; is the type of the external interface for an HTMLELement. For example, DebugElement in Angular or Cy
 *
 */
export interface WidgetObjectElement&lt;T&gt; extends Locator&lt;T&gt;, ElementActions {
    /**
     * Unwraps the value from this WidgetObjectElement and turns it into the resulting object type (T) which is what
     * should be exposed to subclasses
     */
    unwrap(): T;
}

/**
 * A wrapper around a component in UI code. Each subclass typically lives in the same folder as the
 * component itself.
 *
 * It provides two main functions:
 *   - Access to key HTML elements within it so that tests can assert something about their content
 *   - Abstracting interactions. For example, a login method that takes a username and password and
 *     enters it into both fields and then clicks the submit button.
 *
 * These widgets can be used in multiple environments by implementing two pieces:
 * - A subclass of WidgetObjectElement&lt;T&gt; where T is the environment&#x27;s HTMLElement wrapper, such as DebugElement,
 *   Cypress.Chainable or WebElement.
 * - A Widget finder that knows how to instantiate WidgetObjects passing it the correct type of &#x60;WidgetObjectElement&lt;T&gt;&#x60;
 *   which you have created
 *
 * @example
 *
 * class LoginWidgetObject&lt;T&gt; extends BaseWidgetObject&lt;T&gt; {
 *      // Private accessors return WidgetObjectElement using the factory
 *      private _getUserNameInput &#x3D; this.internalFactory.css(&#x27;.username&#x27;);
 *
 *      // Public accessors return T and can be composed from their private counterparts
 *      // Differentiate them by the underscore to make it clear one is returning the internal format
 *      public getUsernameInput &#x3D; this.factory.unwrap(this._getUsernameInput);
 *
 *      // Don&#x27;t need to expose this publicly, user underscore so it&#x27;s clear it returns the WidgetObjectElement
 *      private _getOkButton &#x3D; this.internalFactory.text(&#x27;button&#x27;, OK);
 *
 *      // Don&#x27;t need an internal version, use the factory methods to create public methods
 *      public errorMessage &#x3D; this.factory.dataUi(&#x27;error-message&#x27;);
 *
 *       // Sometimes there&#x27;s no factory for more complex finding logic, write a custom query.
 *       // Be sure to call unwrap on the result if exposing it publicly
 *      getOkButtonContainer(): T {
 *          return this.el.getByText(&#x27;button&#x27;, &#x27;Ok&#x27;).parent(&#x27;.button-container&#x27;).unwrap();
 *      }
 *      ...
 *
 *      login(user, password) {
 *          this._getUsernameInput().type(user);
 *          this._getPasswordInput().type(password);
 *          this._getOkButton().click();
 *      }
 * }
 */
export class BaseWidgetObject&lt;T&gt; {
    /**
     * This is like {@link #factory} but it returns WidgetObjectElements, which can be used internally
     */
    protected internalFactory &#x3D; {
        css: (cssSelector: string) &#x3D;&gt; (options?: FindElementOptions) &#x3D;&gt; this.el.get({ cssSelector, ...options }),
        dataUi: (name: string) &#x3D;&gt; this.internalFactory.css(&#x60;[data-ui&#x3D;&quot;${name}&quot;]&#x60;),
    };

    /**
     * Helpers for creating methods to find HTML elements within the widget object. They can find two types of elements:
     *
     * - WidgetObjectElements&lt;T&gt; which wrap the T which is unknown to this base class into a common interface that
     *   can be be used within to WidgetObject subclasses to provide methods that can abstract interactions with
     *   the widget. For example, a &#x60;loginWidget.login(usr, pwd)&#x60; call which types into the user and password fields
     *   and then hits the submit button; These elements don&#x27;t provide means to assert anything or even to read
     *   information from the widget objects elements such as their text, CSS class names, etc.
     *
     * - The generic specified by &lt;T&gt; which depends on the implementation such as a DebugElement in Angular, a
     *   Chainable in Cypress, or a WebElement in Selenium.
     *
     * Note that unlike Google Material&#x27;s Harnesses, we do not impose a &#x60;TestElement&#x60; interface to be used from
     * different implementations where all the methods return promises. The main reason is that it allows
     * calls from different implementations to feel more natural, according to their testing environment. For example:
     *
     * - Avoids adding &#x60;await&#x60;s all over unit tests where they aren&#x27;t necessarily needed. When trying this approach,
     *   it was tricky to try to convert Cypress values into Promises in a reliable way. It initially looked promising
     *   (pun intended) but turned out not to work with nested promises.
     *
     * - Allows the calls to WidgetObject methods to be more like their native objects instead of forcing them
     *   to comply with a TestElement interface we have defined. That is, Cypress has a natural way to read text at
     *   polling intervals automatically so you can still benefit from that when writing a Cypress Tests while
     *   you would need a different mechanism in your Angular unit tests where you have a DebugElement.
     *
     *   This also prevents widget object methods from querying information about the elements forcing any assertions
     *   to be run from the outside, which we believe is the correct way to structure codes since assertions are
     *   framework specific.
     *
     *   Each factory method returns an ElementLocator&lt;WidgetObjectElement&lt;T&gt;&gt; which should never be public
     *   but also has a corresponding method prefixed with _ to indicate the it returns &#x60;T&#x60; which is what should be
     *   consumed by users of the class.
     */
    protected factory &#x3D; {
        /**
         * Utility to create versions of factories that return the unwrapped T
         */
        unwrap: (fun: ElementLocator&lt;WidgetObjectElement&lt;T&gt;&gt;) &#x3D;&gt; {
            return (options?: FindElementOptions) &#x3D;&gt; fun(options).unwrap();
        },

        css: (cssSelector: string) &#x3D;&gt; this.factory.unwrap(this.internalFactory.css(cssSelector)),

        /** Utility to find by data-ui attribute which is the suggested way to tag elements in the DOM for testing  */
        dataUi: (name: string) &#x3D;&gt; this.factory.unwrap(this.internalFactory.dataUi(name)),
    };

    constructor(protected el: WidgetObjectElement&lt;T&gt;) {}

    /**
     * Gives the element that underlies the current widget object. Use sparingly. A common use case is
     * when you want to test visibility of a widget, which must be done by assertions, which do not belong in a widget
     * object.
     */
    public self(): T {
        return this.el.unwrap();
    }
}

/**
 * The interface that all WidgetObject classes must satisfy. This means that they must:
 *  - extend BaseWidgetObject
 *  - have a static tagName.
 *
 *  T is the type of element returned by its accessors, e.g., Cypress or DebugElement
 *  W is the type of component to be found
 */
export interface FindableWidget&lt;T, W extends BaseWidgetObject&lt;T&gt;&gt; {
    new (driver: WidgetObjectElement&lt;T&gt;): W;
    tagName: string;
}
</code></pre>
    </div>
</div>



                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'class';
            var COMPODOC_CURRENT_PAGE_URL = 'BaseWidgetObject.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
